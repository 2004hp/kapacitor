// Code generated by protoc-gen-gogo.
// source: udf.proto
// DO NOT EDIT!

/*
Package udf is a generated protocol buffer package.

It is generated from these files:
	udf.proto

It has these top-level messages:
	InfoRequest
	InfoResponse
	OptionInfo
	InitRequest
	Option
	OptionValue
	InitResponse
	SnapshotRequest
	SnapshotResponse
	RestoreRequest
	RestoreResponse
	KeepaliveRequest
	KeepaliveResponse
	ErrorResponse
	BeginBatch
	Point
	EndBatch
	Request
	Response
*/
package udf

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type EdgeType int32

const (
	EdgeType_STREAM EdgeType = 0
	EdgeType_BATCH  EdgeType = 1
)

var EdgeType_name = map[int32]string{
	0: "STREAM",
	1: "BATCH",
}
var EdgeType_value = map[string]int32{
	"STREAM": 0,
	"BATCH":  1,
}

func (x EdgeType) String() string {
	return proto.EnumName(EdgeType_name, int32(x))
}

type ValueType int32

const (
	ValueType_BOOL     ValueType = 0
	ValueType_INT      ValueType = 1
	ValueType_DOUBLE   ValueType = 2
	ValueType_STRING   ValueType = 3
	ValueType_DURATION ValueType = 4
)

var ValueType_name = map[int32]string{
	0: "BOOL",
	1: "INT",
	2: "DOUBLE",
	3: "STRING",
	4: "DURATION",
}
var ValueType_value = map[string]int32{
	"BOOL":     0,
	"INT":      1,
	"DOUBLE":   2,
	"STRING":   3,
	"DURATION": 4,
}

func (x ValueType) String() string {
	return proto.EnumName(ValueType_name, int32(x))
}

// Request that the process return information about available Options.
type InfoRequest struct {
}

func (m *InfoRequest) Reset()         { *m = InfoRequest{} }
func (m *InfoRequest) String() string { return proto.CompactTextString(m) }
func (*InfoRequest) ProtoMessage()    {}

type InfoResponse struct {
	Wants    EdgeType               `protobuf:"varint,1,opt,name=wants,proto3,enum=udf.EdgeType" json:"wants,omitempty"`
	Provides EdgeType               `protobuf:"varint,2,opt,name=provides,proto3,enum=udf.EdgeType" json:"provides,omitempty"`
	Options  map[string]*OptionInfo `protobuf:"bytes,3,rep,name=options" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *InfoResponse) Reset()         { *m = InfoResponse{} }
func (m *InfoResponse) String() string { return proto.CompactTextString(m) }
func (*InfoResponse) ProtoMessage()    {}

func (m *InfoResponse) GetOptions() map[string]*OptionInfo {
	if m != nil {
		return m.Options
	}
	return nil
}

type OptionInfo struct {
	ValueTypes []ValueType `protobuf:"varint,1,rep,name=valueTypes,enum=udf.ValueType" json:"valueTypes,omitempty"`
}

func (m *OptionInfo) Reset()         { *m = OptionInfo{} }
func (m *OptionInfo) String() string { return proto.CompactTextString(m) }
func (*OptionInfo) ProtoMessage()    {}

// Request that the process initialize itself with the provided options.
type InitRequest struct {
	Options []*Option `protobuf:"bytes,1,rep,name=options" json:"options,omitempty"`
}

func (m *InitRequest) Reset()         { *m = InitRequest{} }
func (m *InitRequest) String() string { return proto.CompactTextString(m) }
func (*InitRequest) ProtoMessage()    {}

func (m *InitRequest) GetOptions() []*Option {
	if m != nil {
		return m.Options
	}
	return nil
}

type Option struct {
	Name   string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Values []*OptionValue `protobuf:"bytes,2,rep,name=values" json:"values,omitempty"`
}

func (m *Option) Reset()         { *m = Option{} }
func (m *Option) String() string { return proto.CompactTextString(m) }
func (*Option) ProtoMessage()    {}

func (m *Option) GetValues() []*OptionValue {
	if m != nil {
		return m.Values
	}
	return nil
}

type OptionValue struct {
	Type ValueType `protobuf:"varint,1,opt,name=type,proto3,enum=udf.ValueType" json:"type,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*OptionValue_BoolValue
	//	*OptionValue_IntValue
	//	*OptionValue_DoubleValue
	//	*OptionValue_StringValue
	//	*OptionValue_DurationValue
	Value isOptionValue_Value `protobuf_oneof:"value"`
}

func (m *OptionValue) Reset()         { *m = OptionValue{} }
func (m *OptionValue) String() string { return proto.CompactTextString(m) }
func (*OptionValue) ProtoMessage()    {}

type isOptionValue_Value interface {
	isOptionValue_Value()
}

type OptionValue_BoolValue struct {
	BoolValue bool `protobuf:"varint,2,opt,name=boolValue,proto3,oneof"`
}
type OptionValue_IntValue struct {
	IntValue int64 `protobuf:"varint,3,opt,name=intValue,proto3,oneof"`
}
type OptionValue_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,4,opt,name=doubleValue,proto3,oneof"`
}
type OptionValue_StringValue struct {
	StringValue string `protobuf:"bytes,5,opt,name=stringValue,proto3,oneof"`
}
type OptionValue_DurationValue struct {
	DurationValue int64 `protobuf:"varint,6,opt,name=durationValue,proto3,oneof"`
}

func (*OptionValue_BoolValue) isOptionValue_Value()     {}
func (*OptionValue_IntValue) isOptionValue_Value()      {}
func (*OptionValue_DoubleValue) isOptionValue_Value()   {}
func (*OptionValue_StringValue) isOptionValue_Value()   {}
func (*OptionValue_DurationValue) isOptionValue_Value() {}

func (m *OptionValue) GetValue() isOptionValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *OptionValue) GetBoolValue() bool {
	if x, ok := m.GetValue().(*OptionValue_BoolValue); ok {
		return x.BoolValue
	}
	return false
}

func (m *OptionValue) GetIntValue() int64 {
	if x, ok := m.GetValue().(*OptionValue_IntValue); ok {
		return x.IntValue
	}
	return 0
}

func (m *OptionValue) GetDoubleValue() float64 {
	if x, ok := m.GetValue().(*OptionValue_DoubleValue); ok {
		return x.DoubleValue
	}
	return 0
}

func (m *OptionValue) GetStringValue() string {
	if x, ok := m.GetValue().(*OptionValue_StringValue); ok {
		return x.StringValue
	}
	return ""
}

func (m *OptionValue) GetDurationValue() int64 {
	if x, ok := m.GetValue().(*OptionValue_DurationValue); ok {
		return x.DurationValue
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*OptionValue) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _OptionValue_OneofMarshaler, _OptionValue_OneofUnmarshaler, []interface{}{
		(*OptionValue_BoolValue)(nil),
		(*OptionValue_IntValue)(nil),
		(*OptionValue_DoubleValue)(nil),
		(*OptionValue_StringValue)(nil),
		(*OptionValue_DurationValue)(nil),
	}
}

func _OptionValue_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*OptionValue)
	// value
	switch x := m.Value.(type) {
	case *OptionValue_BoolValue:
		t := uint64(0)
		if x.BoolValue {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *OptionValue_IntValue:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.IntValue))
	case *OptionValue_DoubleValue:
		_ = b.EncodeVarint(4<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(math.Float64bits(x.DoubleValue))
	case *OptionValue_StringValue:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.StringValue)
	case *OptionValue_DurationValue:
		_ = b.EncodeVarint(6<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.DurationValue))
	case nil:
	default:
		return fmt.Errorf("OptionValue.Value has unexpected type %T", x)
	}
	return nil
}

func _OptionValue_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*OptionValue)
	switch tag {
	case 2: // value.boolValue
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &OptionValue_BoolValue{x != 0}
		return true, err
	case 3: // value.intValue
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &OptionValue_IntValue{int64(x)}
		return true, err
	case 4: // value.doubleValue
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Value = &OptionValue_DoubleValue{math.Float64frombits(x)}
		return true, err
	case 5: // value.stringValue
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &OptionValue_StringValue{x}
		return true, err
	case 6: // value.durationValue
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &OptionValue_DurationValue{int64(x)}
		return true, err
	default:
		return false, nil
	}
}

// Respond to Kapacitor whether initialization was successful.
type InitResponse struct {
	Success bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error   string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *InitResponse) Reset()         { *m = InitResponse{} }
func (m *InitResponse) String() string { return proto.CompactTextString(m) }
func (*InitResponse) ProtoMessage()    {}

// Request that the process provide a snapshot of its state.
type SnapshotRequest struct {
}

func (m *SnapshotRequest) Reset()         { *m = SnapshotRequest{} }
func (m *SnapshotRequest) String() string { return proto.CompactTextString(m) }
func (*SnapshotRequest) ProtoMessage()    {}

// Respond to Kapacitor with a serialized snapshot of the running state.
type SnapshotResponse struct {
	Snapshot []byte `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
}

func (m *SnapshotResponse) Reset()         { *m = SnapshotResponse{} }
func (m *SnapshotResponse) String() string { return proto.CompactTextString(m) }
func (*SnapshotResponse) ProtoMessage()    {}

// Request that the process restore its state from a snapshot.
type RestoreRequest struct {
	Snapshot []byte `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
}

func (m *RestoreRequest) Reset()         { *m = RestoreRequest{} }
func (m *RestoreRequest) String() string { return proto.CompactTextString(m) }
func (*RestoreRequest) ProtoMessage()    {}

// Respond with success or failure to a RestoreRequest
type RestoreResponse struct {
	Success bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error   string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *RestoreResponse) Reset()         { *m = RestoreResponse{} }
func (m *RestoreResponse) String() string { return proto.CompactTextString(m) }
func (*RestoreResponse) ProtoMessage()    {}

// Request that the process respond with a Keepalive to verify it is responding.
type KeepaliveRequest struct {
	// The number of nanoseconds since the epoch.
	// Used only for debugging keepalive requests.
	Time int64 `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *KeepaliveRequest) Reset()         { *m = KeepaliveRequest{} }
func (m *KeepaliveRequest) String() string { return proto.CompactTextString(m) }
func (*KeepaliveRequest) ProtoMessage()    {}

// Respond to KeepaliveRequest
type KeepaliveResponse struct {
	// The number of nanoseconds since the epoch.
	// Used only for debugging keepalive requests.
	Time int64 `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *KeepaliveResponse) Reset()         { *m = KeepaliveResponse{} }
func (m *KeepaliveResponse) String() string { return proto.CompactTextString(m) }
func (*KeepaliveResponse) ProtoMessage()    {}

// Sent from the process to Kapacitor indicating an error has occured.
// If an ErrorResponse is received, Kapacitor will terminate the process.
type ErrorResponse struct {
	Error string `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ErrorResponse) Reset()         { *m = ErrorResponse{} }
func (m *ErrorResponse) String() string { return proto.CompactTextString(m) }
func (*ErrorResponse) ProtoMessage()    {}

// Indicates the beginning of a batch.
// All subsequent points should be considered
// part of the batch until EndBatch arrives.
type BeginBatch struct {
}

func (m *BeginBatch) Reset()         { *m = BeginBatch{} }
func (m *BeginBatch) String() string { return proto.CompactTextString(m) }
func (*BeginBatch) ProtoMessage()    {}

// Message containing information about a single data point.
// Can be sent on it's own or bookended by BeginBatch and EndBatch messages.
type Point struct {
	Time            int64              `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Name            string             `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Database        string             `protobuf:"bytes,3,opt,name=database,proto3" json:"database,omitempty"`
	RetentionPolicy string             `protobuf:"bytes,4,opt,name=retentionPolicy,proto3" json:"retentionPolicy,omitempty"`
	Group           string             `protobuf:"bytes,5,opt,name=group,proto3" json:"group,omitempty"`
	Dimensions      []string           `protobuf:"bytes,6,rep,name=dimensions" json:"dimensions,omitempty"`
	Tags            map[string]string  `protobuf:"bytes,7,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	FieldsDouble    map[string]float64 `protobuf:"bytes,8,rep,name=fieldsDouble" json:"fieldsDouble,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
	FieldsInt       map[string]int64   `protobuf:"bytes,9,rep,name=fieldsInt" json:"fieldsInt,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	FieldsString    map[string]string  `protobuf:"bytes,10,rep,name=fieldsString" json:"fieldsString,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Point) Reset()         { *m = Point{} }
func (m *Point) String() string { return proto.CompactTextString(m) }
func (*Point) ProtoMessage()    {}

func (m *Point) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Point) GetFieldsDouble() map[string]float64 {
	if m != nil {
		return m.FieldsDouble
	}
	return nil
}

func (m *Point) GetFieldsInt() map[string]int64 {
	if m != nil {
		return m.FieldsInt
	}
	return nil
}

func (m *Point) GetFieldsString() map[string]string {
	if m != nil {
		return m.FieldsString
	}
	return nil
}

// Indicates the end of a batch and contains
// all meta data associated with the batch.
type EndBatch struct {
	Name  string            `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Group string            `protobuf:"bytes,2,opt,name=Group,proto3" json:"Group,omitempty"`
	TMax  int64             `protobuf:"varint,3,opt,name=TMax,proto3" json:"TMax,omitempty"`
	Tags  map[string]string `protobuf:"bytes,4,rep,name=Tags" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *EndBatch) Reset()         { *m = EndBatch{} }
func (m *EndBatch) String() string { return proto.CompactTextString(m) }
func (*EndBatch) ProtoMessage()    {}

func (m *EndBatch) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// Request message wrapper -- sent from Kapacitor to process
type Request struct {
	// Types that are valid to be assigned to Message:
	//	*Request_Info
	//	*Request_Init
	//	*Request_Keepalive
	//	*Request_Snapshot
	//	*Request_Restore
	//	*Request_Begin
	//	*Request_Point
	//	*Request_End
	Message isRequest_Message `protobuf_oneof:"message"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}

type isRequest_Message interface {
	isRequest_Message()
}

type Request_Info struct {
	Info *InfoRequest `protobuf:"bytes,1,opt,name=info,oneof"`
}
type Request_Init struct {
	Init *InitRequest `protobuf:"bytes,2,opt,name=init,oneof"`
}
type Request_Keepalive struct {
	Keepalive *KeepaliveRequest `protobuf:"bytes,3,opt,name=keepalive,oneof"`
}
type Request_Snapshot struct {
	Snapshot *SnapshotRequest `protobuf:"bytes,4,opt,name=snapshot,oneof"`
}
type Request_Restore struct {
	Restore *RestoreRequest `protobuf:"bytes,5,opt,name=restore,oneof"`
}
type Request_Begin struct {
	Begin *BeginBatch `protobuf:"bytes,16,opt,name=begin,oneof"`
}
type Request_Point struct {
	Point *Point `protobuf:"bytes,17,opt,name=point,oneof"`
}
type Request_End struct {
	End *EndBatch `protobuf:"bytes,18,opt,name=end,oneof"`
}

func (*Request_Info) isRequest_Message()      {}
func (*Request_Init) isRequest_Message()      {}
func (*Request_Keepalive) isRequest_Message() {}
func (*Request_Snapshot) isRequest_Message()  {}
func (*Request_Restore) isRequest_Message()   {}
func (*Request_Begin) isRequest_Message()     {}
func (*Request_Point) isRequest_Message()     {}
func (*Request_End) isRequest_Message()       {}

func (m *Request) GetMessage() isRequest_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Request) GetInfo() *InfoRequest {
	if x, ok := m.GetMessage().(*Request_Info); ok {
		return x.Info
	}
	return nil
}

func (m *Request) GetInit() *InitRequest {
	if x, ok := m.GetMessage().(*Request_Init); ok {
		return x.Init
	}
	return nil
}

func (m *Request) GetKeepalive() *KeepaliveRequest {
	if x, ok := m.GetMessage().(*Request_Keepalive); ok {
		return x.Keepalive
	}
	return nil
}

func (m *Request) GetSnapshot() *SnapshotRequest {
	if x, ok := m.GetMessage().(*Request_Snapshot); ok {
		return x.Snapshot
	}
	return nil
}

func (m *Request) GetRestore() *RestoreRequest {
	if x, ok := m.GetMessage().(*Request_Restore); ok {
		return x.Restore
	}
	return nil
}

func (m *Request) GetBegin() *BeginBatch {
	if x, ok := m.GetMessage().(*Request_Begin); ok {
		return x.Begin
	}
	return nil
}

func (m *Request) GetPoint() *Point {
	if x, ok := m.GetMessage().(*Request_Point); ok {
		return x.Point
	}
	return nil
}

func (m *Request) GetEnd() *EndBatch {
	if x, ok := m.GetMessage().(*Request_End); ok {
		return x.End
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Request) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _Request_OneofMarshaler, _Request_OneofUnmarshaler, []interface{}{
		(*Request_Info)(nil),
		(*Request_Init)(nil),
		(*Request_Keepalive)(nil),
		(*Request_Snapshot)(nil),
		(*Request_Restore)(nil),
		(*Request_Begin)(nil),
		(*Request_Point)(nil),
		(*Request_End)(nil),
	}
}

func _Request_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Request)
	// message
	switch x := m.Message.(type) {
	case *Request_Info:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Info); err != nil {
			return err
		}
	case *Request_Init:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Init); err != nil {
			return err
		}
	case *Request_Keepalive:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Keepalive); err != nil {
			return err
		}
	case *Request_Snapshot:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Snapshot); err != nil {
			return err
		}
	case *Request_Restore:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Restore); err != nil {
			return err
		}
	case *Request_Begin:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Begin); err != nil {
			return err
		}
	case *Request_Point:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Point); err != nil {
			return err
		}
	case *Request_End:
		_ = b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.End); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Request.Message has unexpected type %T", x)
	}
	return nil
}

func _Request_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Request)
	switch tag {
	case 1: // message.info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InfoRequest)
		err := b.DecodeMessage(msg)
		m.Message = &Request_Info{msg}
		return true, err
	case 2: // message.init
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InitRequest)
		err := b.DecodeMessage(msg)
		m.Message = &Request_Init{msg}
		return true, err
	case 3: // message.keepalive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KeepaliveRequest)
		err := b.DecodeMessage(msg)
		m.Message = &Request_Keepalive{msg}
		return true, err
	case 4: // message.snapshot
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SnapshotRequest)
		err := b.DecodeMessage(msg)
		m.Message = &Request_Snapshot{msg}
		return true, err
	case 5: // message.restore
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RestoreRequest)
		err := b.DecodeMessage(msg)
		m.Message = &Request_Restore{msg}
		return true, err
	case 16: // message.begin
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BeginBatch)
		err := b.DecodeMessage(msg)
		m.Message = &Request_Begin{msg}
		return true, err
	case 17: // message.point
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Point)
		err := b.DecodeMessage(msg)
		m.Message = &Request_Point{msg}
		return true, err
	case 18: // message.end
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndBatch)
		err := b.DecodeMessage(msg)
		m.Message = &Request_End{msg}
		return true, err
	default:
		return false, nil
	}
}

// Response message wrapper -- sent from process to Kapacitor
type Response struct {
	// Types that are valid to be assigned to Message:
	//	*Response_Info
	//	*Response_Init
	//	*Response_Keepalive
	//	*Response_Snapshot
	//	*Response_Restore
	//	*Response_Error
	//	*Response_Begin
	//	*Response_Point
	//	*Response_End
	Message isResponse_Message `protobuf_oneof:"message"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}

type isResponse_Message interface {
	isResponse_Message()
}

type Response_Info struct {
	Info *InfoResponse `protobuf:"bytes,1,opt,name=info,oneof"`
}
type Response_Init struct {
	Init *InitResponse `protobuf:"bytes,2,opt,name=init,oneof"`
}
type Response_Keepalive struct {
	Keepalive *KeepaliveResponse `protobuf:"bytes,3,opt,name=keepalive,oneof"`
}
type Response_Snapshot struct {
	Snapshot *SnapshotResponse `protobuf:"bytes,4,opt,name=snapshot,oneof"`
}
type Response_Restore struct {
	Restore *RestoreResponse `protobuf:"bytes,5,opt,name=restore,oneof"`
}
type Response_Error struct {
	Error *ErrorResponse `protobuf:"bytes,6,opt,name=error,oneof"`
}
type Response_Begin struct {
	Begin *BeginBatch `protobuf:"bytes,16,opt,name=begin,oneof"`
}
type Response_Point struct {
	Point *Point `protobuf:"bytes,17,opt,name=point,oneof"`
}
type Response_End struct {
	End *EndBatch `protobuf:"bytes,18,opt,name=end,oneof"`
}

func (*Response_Info) isResponse_Message()      {}
func (*Response_Init) isResponse_Message()      {}
func (*Response_Keepalive) isResponse_Message() {}
func (*Response_Snapshot) isResponse_Message()  {}
func (*Response_Restore) isResponse_Message()   {}
func (*Response_Error) isResponse_Message()     {}
func (*Response_Begin) isResponse_Message()     {}
func (*Response_Point) isResponse_Message()     {}
func (*Response_End) isResponse_Message()       {}

func (m *Response) GetMessage() isResponse_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Response) GetInfo() *InfoResponse {
	if x, ok := m.GetMessage().(*Response_Info); ok {
		return x.Info
	}
	return nil
}

func (m *Response) GetInit() *InitResponse {
	if x, ok := m.GetMessage().(*Response_Init); ok {
		return x.Init
	}
	return nil
}

func (m *Response) GetKeepalive() *KeepaliveResponse {
	if x, ok := m.GetMessage().(*Response_Keepalive); ok {
		return x.Keepalive
	}
	return nil
}

func (m *Response) GetSnapshot() *SnapshotResponse {
	if x, ok := m.GetMessage().(*Response_Snapshot); ok {
		return x.Snapshot
	}
	return nil
}

func (m *Response) GetRestore() *RestoreResponse {
	if x, ok := m.GetMessage().(*Response_Restore); ok {
		return x.Restore
	}
	return nil
}

func (m *Response) GetError() *ErrorResponse {
	if x, ok := m.GetMessage().(*Response_Error); ok {
		return x.Error
	}
	return nil
}

func (m *Response) GetBegin() *BeginBatch {
	if x, ok := m.GetMessage().(*Response_Begin); ok {
		return x.Begin
	}
	return nil
}

func (m *Response) GetPoint() *Point {
	if x, ok := m.GetMessage().(*Response_Point); ok {
		return x.Point
	}
	return nil
}

func (m *Response) GetEnd() *EndBatch {
	if x, ok := m.GetMessage().(*Response_End); ok {
		return x.End
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Response) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _Response_OneofMarshaler, _Response_OneofUnmarshaler, []interface{}{
		(*Response_Info)(nil),
		(*Response_Init)(nil),
		(*Response_Keepalive)(nil),
		(*Response_Snapshot)(nil),
		(*Response_Restore)(nil),
		(*Response_Error)(nil),
		(*Response_Begin)(nil),
		(*Response_Point)(nil),
		(*Response_End)(nil),
	}
}

func _Response_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Response)
	// message
	switch x := m.Message.(type) {
	case *Response_Info:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Info); err != nil {
			return err
		}
	case *Response_Init:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Init); err != nil {
			return err
		}
	case *Response_Keepalive:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Keepalive); err != nil {
			return err
		}
	case *Response_Snapshot:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Snapshot); err != nil {
			return err
		}
	case *Response_Restore:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Restore); err != nil {
			return err
		}
	case *Response_Error:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *Response_Begin:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Begin); err != nil {
			return err
		}
	case *Response_Point:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Point); err != nil {
			return err
		}
	case *Response_End:
		_ = b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.End); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Response.Message has unexpected type %T", x)
	}
	return nil
}

func _Response_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Response)
	switch tag {
	case 1: // message.info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InfoResponse)
		err := b.DecodeMessage(msg)
		m.Message = &Response_Info{msg}
		return true, err
	case 2: // message.init
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(InitResponse)
		err := b.DecodeMessage(msg)
		m.Message = &Response_Init{msg}
		return true, err
	case 3: // message.keepalive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KeepaliveResponse)
		err := b.DecodeMessage(msg)
		m.Message = &Response_Keepalive{msg}
		return true, err
	case 4: // message.snapshot
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SnapshotResponse)
		err := b.DecodeMessage(msg)
		m.Message = &Response_Snapshot{msg}
		return true, err
	case 5: // message.restore
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RestoreResponse)
		err := b.DecodeMessage(msg)
		m.Message = &Response_Restore{msg}
		return true, err
	case 6: // message.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ErrorResponse)
		err := b.DecodeMessage(msg)
		m.Message = &Response_Error{msg}
		return true, err
	case 16: // message.begin
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(BeginBatch)
		err := b.DecodeMessage(msg)
		m.Message = &Response_Begin{msg}
		return true, err
	case 17: // message.point
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Point)
		err := b.DecodeMessage(msg)
		m.Message = &Response_Point{msg}
		return true, err
	case 18: // message.end
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EndBatch)
		err := b.DecodeMessage(msg)
		m.Message = &Response_End{msg}
		return true, err
	default:
		return false, nil
	}
}

func init() {
	proto.RegisterType((*InfoRequest)(nil), "udf.InfoRequest")
	proto.RegisterType((*InfoResponse)(nil), "udf.InfoResponse")
	proto.RegisterType((*OptionInfo)(nil), "udf.OptionInfo")
	proto.RegisterType((*InitRequest)(nil), "udf.InitRequest")
	proto.RegisterType((*Option)(nil), "udf.Option")
	proto.RegisterType((*OptionValue)(nil), "udf.OptionValue")
	proto.RegisterType((*InitResponse)(nil), "udf.InitResponse")
	proto.RegisterType((*SnapshotRequest)(nil), "udf.SnapshotRequest")
	proto.RegisterType((*SnapshotResponse)(nil), "udf.SnapshotResponse")
	proto.RegisterType((*RestoreRequest)(nil), "udf.RestoreRequest")
	proto.RegisterType((*RestoreResponse)(nil), "udf.RestoreResponse")
	proto.RegisterType((*KeepaliveRequest)(nil), "udf.KeepaliveRequest")
	proto.RegisterType((*KeepaliveResponse)(nil), "udf.KeepaliveResponse")
	proto.RegisterType((*ErrorResponse)(nil), "udf.ErrorResponse")
	proto.RegisterType((*BeginBatch)(nil), "udf.BeginBatch")
	proto.RegisterType((*Point)(nil), "udf.Point")
	proto.RegisterType((*EndBatch)(nil), "udf.EndBatch")
	proto.RegisterType((*Request)(nil), "udf.Request")
	proto.RegisterType((*Response)(nil), "udf.Response")
	proto.RegisterEnum("udf.EdgeType", EdgeType_name, EdgeType_value)
	proto.RegisterEnum("udf.ValueType", ValueType_name, ValueType_value)
}
